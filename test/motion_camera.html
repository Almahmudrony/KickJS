<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title></title>

    <link rel="stylesheet" href="http://yui.yahooapis.com/3.4.0/build/cssgrids/grids-min.css">

    <script src="http://yui.yahooapis.com/3.4.0/build/yui/yui-min.js"></script>
    <script type="text/javascript" src="../src/constants.js"></script>
    <script type="text/javascript" src="../src/core.js"></script>
    <script type="text/javascript" src="../src/math.js"></script>
    <script type="text/javascript" src="../src/scene.js"></script>
    <script type="text/javascript" src="../src/renderer.js"></script>
    <script type="text/javascript" src="../src/shader.js"></script>
    <script type="text/javascript" src="../src/meshfactory.js"></script>
    <script type="text/javascript">
        var engine;
        var meshRenderer;
        
        var log = function (output) {
            var element = document.getElementById("output");
            element.innerHTML = element.innerHTML+output+"<br>";
        };

        var clearLog = function(){
            var element = document.getElementById("output");
            element.innerHTML = "";
        }

        function setMesh(meshFactoryFunc,subdivisions){
            clearLog();
            meshRenderer.mesh = meshFactoryFunc(engine,subdivisions);
        }

        function setMaterial(vertexShaderId, fragmentShaderId){
            clearLog();
            var vs = document.getElementById(vertexShaderId).value;
            var fs = document.getElementById(fragmentShaderId).value;
            var shader = new KICK.material.Shader(engine);
            shader.initShader(vs,fs,log);
            var missingAttributes = meshRenderer.mesh.verify(shader);
            if (missingAttributes){
                log("Missing attributes in mesh "+JSON.stringify(missingAttributes));
                return;
            }

            meshRenderer.material = new KICK.material.Material({
                name:"Some material",
                shader:shader
            });
        }

        function recalculateNormals(){
            clearLog();
            var mesh = meshRenderer.mesh;
            mesh.recalculateNormals();
            mesh.updateData();
        }

        function recalculateTangents(){
            clearLog();
            var mesh = meshRenderer.mesh;
            mesh.recalculateTangents();
            mesh.updateData();
        }

        function addRotatorComponent(gameObject,id){
            var locx = document.getElementById(id+'locx'),
                locy = document.getElementById(id+'locy'),
                locz = document.getElementById(id+'locz'),
                rotx = document.getElementById(id+'rotx'),
                roty = document.getElementById(id+'roty'),
                rotz = document.getElementById(id+'rotz'),
                scax = document.getElementById(id+'scax'),
                scay = document.getElementById(id+'scay'),
                scaz = document.getElementById(id+'scaz'),
                mat = document.getElementById(id+'mat'),
                matinv = document.getElementById(id+'matinv'),
                transform = gameObject.transform;
            gameObject.addComponent({
                update: function(){
                    
                    //console.log(translate[0],translate[1]);
                    //transform.localRotation = rotation;
                    //transform.localTranslation = translate;
                    transform.localPosition = [locx.value,locy.value,locz.value];
                    transform.localRotationEuler = [rotx.value,roty.value,rotz.value];
                    if (scax){
                        transform.localScale = [scax.value,scay.value,scaz.value];
                    }
                    mat.innerHTML = KICK.math.mat4.strPretty(transform.getGlobalMatrix());
                    matinv.innerHTML = KICK.math.mat4.strPretty(transform.getGlobalTRSInverse());
                }
            });
        }

        function initKick() {
            engine = new KICK.core.Engine('canvas');
            var cameraGameObject = engine.activeScene.createGameObject();
            var camera = new KICK.scene.Camera({
                clearColor: [0,0,0,1]
            });
            cameraGameObject.addComponent(camera);

            var gameObject = engine.activeScene.createGameObject();
            meshRenderer = new KICK.scene.MeshRenderer();
            setMesh(KICK.scene.MeshFactory.createCube, 0.5);
            setMaterial('vertexShaderColor','fragmentShader');
            gameObject.addComponent(meshRenderer);
            addRotatorComponent(cameraGameObject,"");
            addRotatorComponent(gameObject,"cube_");
        }

        var mouseDown = null;
        var direction = 0;

        function increateElementValue(){
            if (mouseDown){
                mouseDown.value = (0.1*direction)+new Number(mouseDown.value);
                setTimeout(increateElementValue,100);
            }
        }

        function registerListener(id){
            var elem = document.getElementById(id);
            elem.onmousedown = function(e){
                mouseDown = elem;
                direction = e.button===0?1:-1;
                increateElementValue();

            };
        }

        function registerListeners(id){
            registerListener(id+"x");
            registerListener(id+"y");
            registerListener(id+"z");
        }



    </script>
</head>
<body onload="initKick();">
  <canvas id="canvas" style="border: none;" width="300" height="300"></canvas> <br>
  This example shows how a cube is rotated.
  <br>

  <h2>Output</h2>
  <div id="output" style="color: red;">
  </div>
  <h2>Camera position</h2>
  Location <input id="locx" value="0"><input id="locy" value="0"><input id="locz" value="10"><br>
  Rotation <input id="rotx" value="0"><input id="roty" value="0"><input id="rotz" value="0"><br>
    Matrix (read only) [Global and global inverse]:<br>
  <textarea style="width:100px;height:60px" id="mat" readonly="readonly">

</textarea>
  <textarea style="width:100px;height:60px" id="matinv" readonly="readonly">

</textarea>
  <h2>Cube position</h2>
  Location <input id="cube_locx" value="0"><input id="cube_locy" value="0"><input id="cube_locz" value="0"><br>
  Rotation <input id="cube_rotx" value="0"><input id="cube_roty" value="0"><input id="cube_rotz" value="0"><br>
  Scale <input id="cube_scax" value="1"><input id="cube_scay" value="1"><input id="cube_scaz" value="1"><br>
    Matrix (read only) [Global and global inverse]:<br>
  <textarea style="width:100px;height:60px" id="cube_mat" readonly="readonly">

</textarea>
  <textarea style="width:100px;height:60px" id="cube_matinv" readonly="readonly">

</textarea>
  <div id="example" class="yui3-skin-sam"></div>

  <div style="display:none;">
  <textarea style="width:500px;height:150px;" id="vertexShaderColor">
attribute vec3 vertex;
attribute vec4 color;

uniform mat4 _mvProj;

varying vec3 vColor;

void main(void) {
    gl_Position = _mvProj * vec4(vertex, 1.0);
    vColor = color.xyz;
}
  </textarea>
  <textarea style="width:500px;height:150px;" id="fragmentShader">
#ifdef GL_ES
precision highp float;
#endif
varying vec3 vColor;
void main(void)
{
    gl_FragColor = vec4(vColor.x, vColor.y, vColor.z, 1.0);
}
  </textarea>
</div>
  <br/>
<script type="text/javascript">
     registerListeners("loc");
        registerListeners("rot");
        registerListeners("cube_loc");
        registerListeners("cube_rot");
        registerListeners("cube_sca");
        document.onmouseup = function(){
            mouseDown = null;
        };
</script>
</body>
</html>