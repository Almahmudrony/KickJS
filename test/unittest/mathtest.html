<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title></title>
            <link rel="stylesheet" href="http://yui.yahooapis.com/3.4.0/build/cssgrids/grids-min.css">

            <link rel="stylesheet" href="/combo/css?main-min.css">

        <link rel="stylesheet" href="/vendor/prettify/prettify-min.css">
        <link rel="stylesheet" href="/css/docs-min.css">
<script src="../../src/js/constants.js"></script>
<script src="../../src/js/math.js"></script>
    <!-- allows to use random seed -->
    <script type="text/javascript">
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512">
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//                             Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow
 * @param {number=} startdenom
 */
(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
})(
  [],   // pool: entropy pool starts empty
  Math, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
);
    </script>



<script src="http://yui.yahooapis.com/3.4.0/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<h1>Math test</h1>
<style scoped>
    #testLogger {
        margin-bottom: 1em;
    }

    #testLogger .yui3-console .yui3-console-title {
        border: 0 none;
        color: #000;
        font-size: 13px;
        font-weight: bold;
        margin: 0;
        text-transform: none;
    }
    #testLogger .yui3-console .yui3-console-entry-meta {
        margin: 0;
    }

    .yui3-skin-sam .yui3-console-entry-pass .yui3-console-entry-cat {
        background: #070;
        color: #fff;
    }
    </style>

    <div id="testLogger"></div>

<script>
Math.seedrandom("hello");
YUI().use('node', 'console', 'test', function (Y) {

    Y.namespace("KICK.math");

    Y.KICK.math.vec3Test = new Y.Test.Case({

        //name of the test case - if not provided, one is auto-generated
        name : "vec3test",

        //---------------------------------------------------------------------
        // setUp and tearDown methods - optional
        //---------------------------------------------------------------------

        /*
         * Sets up data that is needed by each test.
         */
        setUp : function () {
        },

        /*
         * Cleans up everything that was created by setUp().
         */
        tearDown : function () {
        },

        //---------------------------------------------------------------------
        // Test methods - names must begin with "test"
        //---------------------------------------------------------------------

        testVec3Array : function () {
            var Assert = Y.Assert;

            var ref = {};
            var v = KICK.math.vec3.array(2,ref);
            v[1][1] = 1;
            
            Assert.areEqual(ref.mem[4],v[1][1]);
            Assert.areEqual(3,v[1].length);
            Assert.areEqual(0,v[0][0]);
            Assert.areEqual(0,v[0][1]);
            Assert.areEqual(0,v[0][2]);
            Assert.areEqual(0,v[1][0]);
            Assert.areEqual(0,v[1][2]);
        },
        testVec3WrapArray : function () {
            var Assert = Y.Assert;

            var array = new Float32Array(6);
            for (var i=0;i<6;i++){
                array[i] = i;
            }
            var wrappedArray = KICK.math.vec3.wrapArray(array);

            Assert.areEqual(wrappedArray.length,2);
            Assert.areEqual(wrappedArray[0].length,3);
            Assert.areEqual(wrappedArray[1].length,3);
            Assert.areEqual(wrappedArray[0][0],0);
            Assert.areEqual(wrappedArray[0][1],1);
            Assert.areEqual(wrappedArray[0][2],2);
            Assert.areEqual(wrappedArray[1][0],3);
            Assert.areEqual(wrappedArray[1][1],4);
            Assert.areEqual(wrappedArray[1][2],5);
        },                
        testVec3LengthSqr: function () {
            var Assert = Y.Assert;

            var v1 = [1,2,3];
            var v2 = [-1,-2,-3];
            var lenSqr1 = KICK.math.vec3.lengthSqr(v1);
            var lenSqr2 = KICK.math.vec3.lengthSqr(v2);

            Assert.areEqual(14,lenSqr1);
            Assert.areEqual(14,lenSqr2);
        },
        testVec3Multiply: function () {
            var Assert = Y.Assert;

            var v1 = [1,2,3];
            var v2 = [-1,-2,3];
            var res = KICK.math.vec3.multiply(v1,v2,KICK.math.vec3.create());
            var expected = KICK.math.vec3.create([-1,-4,9]);
            for (var i=0;i<3;i++){
                Assert.areEqual(expected[i],res[i]);
            }
        },
        testVec4WrapArray : function () {
            var Assert = Y.Assert;

            var array = new Float32Array(8);
            for (var i=0;i<8;i++){
                array[i] = i;
            }
            var wrappedArray = KICK.math.vec4.wrapArray(array);

            Assert.areEqual(wrappedArray.length,2);
            Assert.areEqual(wrappedArray[0].length,4);
            Assert.areEqual(wrappedArray[1].length,4);
            Assert.areEqual(wrappedArray[0][0],0);
            Assert.areEqual(wrappedArray[0][1],1);
            Assert.areEqual(wrappedArray[0][2],2);
            Assert.areEqual(wrappedArray[0][3],3);
            Assert.areEqual(wrappedArray[1][0],4);
            Assert.areEqual(wrappedArray[1][1],5);
            Assert.areEqual(wrappedArray[1][2],6);
            Assert.areEqual(wrappedArray[1][3],7);
        },
        testVec4Array : function () {
            var Assert = Y.Assert;

            var ref = {};
            var v = KICK.math.vec4.array(2,ref);
            v[1][1] = 1;
            Assert.areEqual(ref.mem[5],v[1][1],"Memory location");
            Assert.areEqual(4,v[1].length,"Content");
            Assert.areEqual(0,v[1][3],"Zero'ed");
        },
        testQuad4SetEuler: function(){
            var Assert = Y.Assert;
            var quat4 = KICK.math.quat4.create();
            for (var i=0;i<1000;i++){
                var euler = KICK.math.vec3.create();
                if (i<3){
                    euler[i] = 90; // test 90 degree rotation
                } else {
                    euler = [Math.random()*720-360,Math.random()*720-360,Math.random()*720-360];
                }
                KICK.math.quat4.setEuler(euler,quat4);
                var mat = KICK.math.mat4.create();
                KICK.math.mat4.identity(mat);
                KICK.math.mat4.rotateEuler(mat,euler);
                var point = [Math.random()*720-360,Math.random()*720-360,Math.random()*720-360];

                var matrixPoint = KICK.math.vec3.create();
                var quatPoint = KICK.math.vec3.create();
                KICK.math.mat4.multiplyVec3(mat,point,matrixPoint);
                KICK.math.quat4.multiplyVec3(quat4,point,quatPoint);
                var msg = "matrixPoint:\n"+KICK.math.vec3.str(matrixPoint)+
                        "\nquatPoint:\n"+KICK.math.vec3.str(quatPoint);
                Assert.compareVec(matrixPoint,quatPoint,msg);
            }
        },
        testQuad4SetEulerToMatrix: function(){
            var Assert = Y.Assert;
            var quat4 = KICK.math.quat4.create();
            for (var i=0;i<1000;i++){
                var euler = KICK.math.vec3.create();
                if (i<3){
                    euler[i] = 90; // test 90 degree rotation
                } else {
                    euler = [Math.random()*720-360,Math.random()*720-360,Math.random()*720-360];
                }
                KICK.math.quat4.setEuler(euler,quat4);
                var quatMat = KICK.math.quat4.toMat4(quat4);
                var mat = KICK.math.mat4.create();
                KICK.math.mat4.identity(mat);
                KICK.math.mat4.rotateEuler(mat,euler);

                var msg = "quat euler to matrix:\n"+KICK.math.mat4.strPretty(quatMat)+
                        "\nmat euler:\n"+KICK.math.mat4.strPretty(mat);
                Assert.compareVec(quatMat,mat,msg);
            }
        },

        testQuad4AngleAxis: function(){
            var Assert = Y.Assert;
            var quat4 = KICK.math.quat4.create();

            var rotationAxis = [[1,0,0],[0,1,0],[0,0,1]];
            var rotationAxisMatFunc = [KICK.math.mat4.rotateX,KICK.math.mat4.rotateY,KICK.math.mat4.rotateZ];
            for (var i=0;i<3;i++){
                var angle = 12.145;
                KICK.math.quat4.angleAxis(angle,rotationAxis[i],quat4);
                var mat = KICK.math.mat4.create();
                KICK.math.mat4.identity(mat);
                rotationAxisMatFunc[i](mat,angle*KICK.core.Constants._DEGREE_TO_RADIAN);

                var point = KICK.math.vec3.create([12.451,123.5,.9]);

                var matrixPoint = KICK.math.vec3.create();
                var quatPoint = KICK.math.vec3.create();
                KICK.math.mat4.multiplyVec3(mat,point,matrixPoint);
                KICK.math.quat4.multiplyVec3(quat4,point,quatPoint);

                var msg = "matrixPoint:\n"+KICK.math.vec3.str(matrixPoint)+
                        "\nquatPoint:\n"+KICK.math.vec3.str(quatPoint)+
                        "\nAxis: "+i;
                Assert.compareVec(matrixPoint,quatPoint,msg);
            }
        },
        testQuad4Euler: function(){
            var Assert = Y.Assert;
            var quat = KICK.math.quat4.create([0,0,0,1]);
            var vec = KICK.math.vec3.create([0,0,0]);

            KICK.math.quat4.toEuler(quat,vec);
            Assert.compareVec([0,0,0],vec);
        },
        testQuad4EulerRotation: function(){
            var Assert = Y.Assert;
            var quat = KICK.math.quat4.create([0,0,0,1]);
            KICK.math.quat4.setEuler([0,180,0],quat);
            var left = KICK.math.vec3.create([1,0,0]);
            var right = KICK.math.vec3.create([-1,0,0]);
            var res = KICK.math.vec3.create([0,0,0]);
            var testRotation = KICK.math.quat4.create();
            KICK.math.quat4.angleAxis(180,[0,1,0],testRotation);
            KICK.math.quat4.multiplyVec3(testRotation,left,res);
            Assert.compareVec(res,right);
            KICK.math.quat4.multiplyVec3(quat,left,res);
            Assert.compareVec(res,right);
            KICK.math.quat4.multiplyVec3(quat,right,res);
            Assert.compareVec(res,left);
        },
        testQuad4Difference: function(){
            var Assert = Y.Assert;
            var quat1 = KICK.math.quat4.create([0,0,0,1]);
            var quat2 = KICK.math.quat4.create([0,0,0,1]);

            KICK.math.quat4.setEuler([15,0,0],quat1);
            KICK.math.quat4.setEuler([-25,0,0],quat2);
            var res = KICK.math.quat4.difference(quat1,quat2);
            var resEuler = KICK.math.quat4.toEuler(res);
            Assert.compareVec([-40,0,0],resEuler);
        },
        testCartesialToSpherical:function(){
            var Assert = Y.Assert;
            var vecCartesial = [1,0,0];
            var spherical = KICK.math.vec3.cartesianToSpherical(vecCartesial);
            Assert.compareVec (spherical,[1,0,0]);

            vecCartesial = [0,0,1];
            spherical = KICK.math.vec3.cartesianToSpherical(vecCartesial);
            Assert.compareVec (spherical,[1,-1.5707963705062866,0]);

            vecCartesial = [0,0,0];
            spherical = KICK.math.vec3.cartesianToSpherical(vecCartesial);
            Assert.compareVec (spherical,[0,0,0]);

            for (var i=0;i<100;i++){
                vecCartesial = [Math.random()*100-50,Math.random()*100-50,Math.random()*100-50];
                spherical = KICK.math.vec3.cartesianToSpherical(vecCartesial);
                var vecCartesial2 = KICK.math.vec3.sphericalToCarterian(spherical);
                Assert.compareVec(vecCartesial,vecCartesial2,"Error in "+i);
            }
        },
        testDecomposeMat4:function(){
            var Assert = Y.Assert;
            var quat4 = KICK.math.quat4;
            var translate = [10,20,30];
            var rotate = [0,0,0,1];
            var scale = [1,2,3];
            for (var i=0;i<10000;i++){
                translate = [Math.random()*100-50,Math.random()*100-50,Math.random()*100-50];
                rotate = quat4.setEuler([Math.random()*360,Math.random()*360,Math.random()*360],rotate);
                quat4.normalize(rotate);
                scale = [Math.random()*100,Math.random()*100,Math.random()*100];
                var matrix = KICK.math.mat4.setTRS (translate , rotate , scale);
                var decomposedMatrix = KICK.math.mat4.decompose(matrix);
                var decomposedTranslate = decomposedMatrix[0];
                var decomposedRotate = decomposedMatrix[1];
                var decomposedScale = decomposedMatrix[2];

                Y.Assert.compareVec(translate,decomposedTranslate);
                Y.Assert.compareQuat4(rotate,decomposedRotate);
                Y.Assert.compareVec(scale,decomposedScale);
            }
        },
        testRotation: function(){
            var quat4 = KICK.math.quat4;
            var someRotation = quat4.setEuler([0,10,1]);
            var rotate = quat4.create([0,0,0,1]);
            var scale = [1,2,3];
        }
    });

    Y.Assert.compareQuat4 = function(expected,actual, message){
        var quat4 = KICK.math.quat4;
        var epsilon = 0.001;
        var isEqual = function(quat){
            for (var i=0;i<4;i++){
                if (Math.abs(expected[i]-quat[i])>epsilon){
                    return false;
                }
            }
            return true;
        };
        if (isEqual(actual)){
            return;
        }
        var actualAlternative = quat4.create([actual[0]*-1,actual[1]*-1,actual[2]*-1,actual[3]*-1]);
        if (isEqual(actualAlternative)){
            return;
        }
        var message = "Expected \n"+KICK.math.vec4.str(expected)+" \nActual \n"+KICK.math.vec4.str(actual);
        Y.Assert.isTrue(false,message);
    };

    /// extend Asset to compare float values
    Y.Assert.compareVec = function(expected,actual,message){
        if (!message){
            if (expected.length==3){
                message = "Expected "+KICK.math.vec3.str(expected)+" Actual "+KICK.math.vec3.str(actual);
            }
        }
        var vectorType;
        if (expected.length==2){
            vectorType = KICK.math.vec2;
        } else if (expected.length==3){
            vectorType = KICK.math.vec3;
        } else if (expected.length==4){
            vectorType = KICK.math.vec4;
        }
        if (vectorType){
            Y.Assert.isTrue(vectorType.equal(expected,actual,0.001),message);
        } else {
            for (var i=0;i<expected.length;i++){
                Y.Assert.compareFloat(expected[i],actual[i],message);
            }
        }
    };
    Y.Assert.compareFloat = function(f1,f2,message){
        var epsilon = 0.001;
        var res = Math.abs(f1-f2)<epsilon;
        if (!res){
            debugger;
        }
        return Y.Assert.isTrue(res,message);
    };

    var ExampleSuite = new Y.Test.Suite("Example Suite");
    ExampleSuite.add(Y.KICK.math.vec3Test);

    /**
     * Rotates a matrix by three rotations given in eulers angles<br>
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     * This method is only used to verify quaternion rotation and therefor not available in math.js
     * @method rotateEuler
     * @param {KICK.math.mat4} mat mat4 to rotate
     * @param {KICK.math.vec3} eulerAngle angle (in degrees) to rotate
     * @param {KICK.math.mat4} dest Optional, mat4 receiving operation result. If not specified result is written to mat
     * @return {KICK.math.mat4} dest if specified, mat otherwise
     */
    KICK.math.mat4.rotateEuler = function(mat, eulerAngle, dest) {
        var degreeToRadian = KICK.core.Constants._DEGREE_TO_RADIAN;
        if (dest) {
            mat4.set(mat,dest);
            mat = dest;
        }

        // Note unoptimized code
        if (eulerAngle[2] !== 0){
            mat4.rotateZ(mat, eulerAngle[2]*degreeToRadian);
        }
        if (eulerAngle[1] !== 0){
            mat4.rotateY(mat, eulerAngle[1]*degreeToRadian);
        }
        if (eulerAngle[0] !== 0){
            mat4.rotateX(mat, eulerAngle[0]*degreeToRadian);
        }
        return mat;
    };

    //create the console
    var r = new Y.Console({
        newestOnTop : false,
        style: 'block', // to anchor in the example content,
        width: 600,
        height: 600
    });

    r.render('#testLogger');

    Y.Test.Runner.add(ExampleSuite);

    //run the tests
    Y.Test.Runner.run();

});
</script>

</div>

</body>
</html>